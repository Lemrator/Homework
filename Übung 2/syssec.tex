\documentclass[]{scrreprt}
\usepackage{listings}
\lstset{numbers=left}
%opening
\title{Systemsicherheit - 2. Übung}
\author{Dennis Rotärmel, Niklas Entschladen, Tobias Ratajczyk, Gruppe Q}

\begin{document}

\maketitle
\chapter{Aufgabe 1}
\subsection*{a)}
Folgender Assembly-code führt die Berechnung aus:
\begin{lstlisting}
	imul ecx, ecx ;ecx*ecx
	sub ecx, ebx ;ecx*ecx-ebx
	shl eax, 1 ;eax*2
	add eax, ecx ;ecx*ecx-ebx+eax*2
	add ebx, 0xaaaa ;ebx+0xaaaa
	xor eax, ebx ;(ecx*ecx-ebx+eax*2)^(ebx+0xaaaa)
\end{lstlisting}
Die Ausgabe des Programms lautet: \texttt{12345}.
\chapter{Aufgabe 2}
\subsection*{a)}
Bei der Ausführung des Programmes wird der jeweils i-te Buchstabe um den Wert i-1 erhöht (siehe ASCII-Tabelle).
Danach wird der daraus entstehende String mit folgendem String vergleichen: "HPFRV".
Daraus lässt sich schlussfolgern, dass das Schlüsselwort "HODOR" lautet. Die Eingabe des Wortes bestätigt dies.
Bis auf den Befehl "break verif\_key" und die dazugehörigen step- und continue-Anweisungen wurden keine weiteren Befehle benötigt.
\subsection*{b)}
\begin{lstlisting}
#include <stdio.h>

int verify_key(char *str){
	char key[5] = "HPFRV";

	for(int i=0; i<5; i++){
		if (str[i]!=key[i]){
			printf("Key is not valid :(\n");
			return 0;
		}
	}
	printf("Key is valid! Whoop whoop :)\n");
	return 0;
}
	
int main(){
	char str[5];
	printf("Enter serial (5 capital letters): ");
	scanf("%s", str);
	
	for(int i=0; i<5; i++){
		str[i]=str[i]+i;
	}

	return verify_key(str);
}
\end{lstlisting}
\chapter{Aufgabe 3}
\subsection*{a)}
\begin{itemize}
	\item \textbf{Data Movement}:
	
	\item  \textbf{Arithmetic and Logic}:
	\begin{itemize}
		\item \texttt{xor eax, eax} $\hat{=}$ eax $\oplus$ eax = 0
		\item \texttt{add eax, 1234h} $\hat{=}$ eax + 4660 = 0 + 4660 = 4660
		\item \texttt{ror eax, 16} $\hat{=}$ {0001001000110100}\textsubscript{2} $\rightarrow$ {0011010000010010}\textsubscript{2} $\hat{=}$  {13330}\textsubscript{10}
		\item \texttt{or eax, 55h} $\hat{=}$ {0011010000010010}\textsubscript{2} $\vee$ {0000000001010101}\textsubscript{2} = {0011010001010111}\textsubscript{2} $\hat{=}$ {13399}\textsubscript{10}
		\item \texttt{inc eax} $\hat{=}$ = eax + 1 = 13400
		\item \texttt{shl ax, 8} $\hat{=}$ 0011010001011000\textsubscript{2} $\rightarrow$ 0011010001011000\textsubscript{2} (ax = 0, somit keine Änderung)
		\item  \texttt{mov al, 78h} $\hat{=}$ 0011010001011000\textsubscript{2} $\rightarrow$ 0011010001110100\textsubscript{2} $\hat{=}$ 13428\textsubscript{10}
		\item Damit ist am Ende der Wert 13428 im \texttt{eax} Register
	\end{itemize}
	
	\item \textbf{Control Flow}:
	\begin{itemize}
		\item \texttt{mov eax, 1h} $\hat{=}$ eax = 00\dots0001
		\item \texttt{neg eax} $\hat{=}$ eax = 11\dots1111
		\item \texttt{mov ebx, FFFFFFF8h}
		\item \texttt{cmp eax, ebx} 
		\item \texttt{jg true} $\rightarrow$ ebx ist größer als eax (da Vorzeichen beachtet)
		\item \texttt{mov eax, 0} wird ausgeführt
		\item damit ist im eax der Wert 0 am Ende.
	\end{itemize}
\end{itemize}
\subsection*{b)}
\texttt{ja} ist ein unsigned-Vergleich, damit wird beim vergleichen das Vorzeichen nicht beachtet. In diesem Fall ist der Wert im \texttt{eax} größer und es wird \texttt{mov eax, 1} ausgeführt.
\end{document}
